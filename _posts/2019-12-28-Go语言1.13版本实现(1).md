---
layout: post
title: "Go语言1.13版本实现(1)"
description: ""
category : Go语言
tags : [language, go]
---
{% include JB/setup %}

# 目录

<ol><script src="http://code.jquery.com/jquery-1.7.2.min.js"></script><script type="text/javascript"> $(document).ready(function(){ $("h2,h3,h4,h5,h6").each(function(i,item){ var tag = $(item).get(0).localName; $(item).attr("id","wow"+i); $("#category").append('<a class="new'+tag+'" href="#wow'+i+'">'+$(this).text()+'</a></br>'); $(".newh2").css("margin-left",0); $(".newh3").css("margin-left",20); $(".newh4").css("margin-left",40); $(".newh5").css("margin-left",60); $(".newh6").css("margin-left",80); }); }); </script><div id="category"></div></ol>

## 1.源代码获取

> 截止目前`2019-12-28`为止，最新版本为：`1.13.5`

直接从Golang官方网站下载：[https://dl.google.com/go/go1.13.5.src.tar.gz](https://dl.google.com/go/go1.13.5.src.tar.gz)

## 2. 新版本和早期版本的实现差异

* runtime改用`golang`+`plan 9汇编`实现，早期版本使用`C`+`plan 9汇编`

## 3. Go程序如何启动

启动点代码在`src/runtime/rt0_xxx_xxx.s`中，用`plan 9汇编`编写，按照go的规范，按照`rt0_{OS}_{Arch}.s`的形式命名源代码。

* `rt0`表示源代码名称
* {OS} 表示的是操作系统名，可取值：`linux`/`android`/`darwin`/`dragonfly`/`freebsd`/`illumos`/`nacl`/`netbsd`/`openbsd`/`pan9`/`solaris`/`windows`，代表了go所支持的操作系统。
* {Arch} 表示体系结构，可取值：`386`/`amd64`/`arm`/`arm64`/`mips64x`/`mipsx`/`ppc64`/`ppc64le`，表示go所支持的体系结构。

例如：rt0_linux_amd64.s 表示 运行于linux操作系统下，amd64(x86-64) CPU下的启动代码。

> 以下内容以linux操作系统，amd64为例进行说明


### 3.1 rt0 过程

`src/runtime/rt0_linux_amd64.s` 并无实际内容，只有两个函数：`_rt0_amd64_linux`, `_rt0_amd64_linux_lib`，这两个函数中只有一条指令，就是分别跳转到`_rt0_amd64`/`_rt0_amd64_lib`，似乎暗示：在所有amd64体系结构中，启动点都是`_rt0_amd64`/`_rt0_amd64_lib`，与操作系统无关。查看了其他操作系统版本的实现，发现确实如此，大部分OS在amd64体系结构中，都是跳转到同样的函数，部分OS有一些特殊处理。

`_rt0_amd64`/`_rt0_amd64_lib` 定义在`src/runtime/asm_amd64.s`中：

1. 先看`_rt0_amd64`: 从注释得知，当用内部链接（internal linking）时这是大部分amd64系统的常规启动点，使用-buildmode=exe参数的程序会使用到这个启动点。堆栈遵从C风格的argv；它只做了很简单的事：
	* 将rsp+0移动到rdi(C ABI的第1个操作数)
	* 取rsp+8的有效地址到rsi(C ABI的第2个操作数)
	* 跳转到runtime·rt0_go函数
	* 上面的操作相当于设置argc、argv到第1，第2个参数，然后跳转到runtime·rt0_go函数
2. `main`: 当使用外部链接(external linking)时，这也是大部分amd64系统的常规启动点；C启动代码将会调用符号："main"（就是本函数），并传递argc、argv作为参数（按照C abi，因该是rdi, rsi这个两个寄存器里）。`rt0_linux_amd64.s`，并没有引用这个函数，因为它是C启动代码直接通过调用符号"main"调用的。这个函数没有任何操作，只是简单的跳转到`runtime·rt0_go`函数
3. `_rt0_amd64_lib`: `_rt0_amd64`和`main`都是作为独立程序的启动点，`_rt0_amd64_lib`不同于它们，它是作为静态/动态库的启动点。当使用-buildmode=c-archive或者-buildmode=c-shared参数时候，链接器将会把这个函数作为构造器，即第一次加载时调用，也会传递遵从C ABI传递argc、argv两个参数。
	* `_rt0_amd64_lib`会按C ABI要求，保护并恢复以下寄存器：rbx,r12,r13,r14,r15
	* 调用runtime·libpreinit进行同步初始化
	* 如果支持cgo：调用_cgo_sys_thread_create(\_rt0_amd64_lib_go, NULL)创建一个新线程完成go runtime初始化；即在新线程中调用_rt0_amd64_lib_go，\_rt0_amd64_lib_go其实就是设置argc、argv然后调用runtime·rt0_go
	* 如果不支持cgo：调用runtime·newosproc0(0x800000, \_rt0_amd64_lib_go)，注意：  runtime·newosproc0是一个go函数，调用方式不遵从C ABI，而使用go ABI，完全使用栈传递参数。这个函数先分配 0x800000（8MB）的栈空间，然后使用clone系统调用fork一个新线程，然后在新线程中执行runtime·rt0_go。
	* 可见：最终执行过程一定是启动一个新线程，异步执行runtime·rt0_go


以上三个启动点，最后一定会调用runtime·rt0_go，可见runtime·rt0_go才是rt0的最终阶段。


`runtime·rt0_go` 定义在`src/runtime/asm_amd64.s`中：


